Less 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、嵌套、运算符、混合（mixin）、继承、函数等功能。详情可参考：https://less.bootcss.com/

1、cookie，sessionStorage，localStorage是存放在客户端，session对象数据是存放在服务器上，实际上浏览器和服务器之间仅需传递session id即可，服务器根据session-id找到对应的用户session对象，session存储数据更安全一些，一般存放用户信息，浏览器只适合存储一般的数据；

2、cookie数据始终在同源的http请求中携带，在浏览器和服务器来回传递，里面存放着session-id、sessionStorage，localStorage仅在本地保存；

3、大小限制区别，cookie数据不超过4kb，localStorage在谷歌浏览中2.6MB；

4、数据有效期不同，cookie在设置的（服务器设置）有效期内有效、不管窗口和浏览器关闭，sessionStorage仅在当前浏览器窗口关闭前有效、关闭即销毁（临时储存），localStorage始终有效（除非主动删除数据）；

5、localStorage和sessionStorage不会随着http 发送到服务器端，所以安全性相对于cookie来说会比较高一点，不会担心截获，但仍然存在伪造问题。

ps: cookie 保存位置：如果没有设置过期时间，则保存在内存中，浏览器关闭即销毁；
                    如何设置了过期时间，则保存在系统硬盘中，即到期后才销毁


token、cookie、session三者的理解：
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的）用户身份的验证方式；

    2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）；
缺点：1.数量和长度的限制，每个特定的域名下最多生成20个cookie（chorme和safari没有限制）；2.安全性问题
优点：保存客户端数据，分担了服务器存储的负担；

    3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）cookie中存放着sessionID，请求会发送这个id，sesion因为request对象而产生；
    

TCP三次握手：
   客服端发c起请求连接服务器端s确认，服务器端也发起连接确认客服端确认。

   第一次握手：客服端发送一个请求连接，服务器端只能确认自己可以接受客服端发送的报文段；
   
   第二次握手： 服务端向客服端发送一个链接，确认客服端收到自己发送的报文段；
   
   第三次握手： 服务器端确认客服端收到了自己发送的报文段；

get/post的区别：
   . get是从服务器上获取数据，post是像服务器传送数据；
   
   . get请求可以将查询字符串参数追加到url的末尾,post是放在请求体中；
   
   . get请求可以被浏览器缓存、收藏、记录，post不会；
   
   . get提交的数据大小有限制，（因为浏览器对url的长度有限制），post的方法提交的数据没有限制;
   
   . get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量的值;
   
   . get的方法提交数据，会带来安全问题，比如登录一个页面，通过get的方式提交数据，用户名和密码就会出现在url上,post比get安全性更高;
   
 js中深拷贝和浅拷贝的区别？
   答：简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明是浅拷贝，如果B没变，那就是深拷贝。
       深入点来说，就是B复制了A，如果B复制的是A的引用，那就是浅拷贝，如果B复制的是A的本体，那就是深拷贝。
   
vue知识点：

 1、第一次页面加载会触发哪几个钩子？
   答：会触发 下面这几个beforeCreate, created, beforeMount, mounted 。
   
 2、Vue与Angular以及React的区别？
 
   1、与AngularJS的区别：
   相同点： 都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。
   不同点： 
     AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；
  在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的；
     
   2、与React的区别：
   相同点: 
     React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，
   组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。
   不同点： React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。
   
3、vue.js的两个核心是什么？
   答：数据驱动、组件系统
   
   
 父组件向子组件传值？
  父组件通过标签属性传值，子组件通过props接收值
  
  子组件向父组件传值？
    父组件通过V-On绑定属性事件，子组件通过this.$emit("方法名"，"参数")来触发父组件的方法
    
    
  兄弟组件之间传值或多级组件之间传值？
   1、先传给父组件，再有父组件传给子组件；
   2、建立一个公共组件，比如bus组件，两个子组件分别引入bus组件，然后通过 bus.$emit("方法名"，"参数") 来发送数据，通过 bus.$on("方法名"，"参数")来监听数据；
  
   
4、 es6有哪些新语法，和es5有什么区别？
   答：. 新增let、const变量，箭头函数，模板字符串，class类，模块化，promise；
       . ES5 reuqire,react,createclass
      
   let、const、var三者的区别？
   答：var声明的是一个变量，存在变量提升（即变量可以在声明之前使用，但值为undefined）；
       let作用域是块级作用域，不存在变量声明提前；不能重复定义；不会成为全局对象的属性（如：let a =3, console.log(window.a) // undefined）;
       const一般声明的是常量，一旦声明，常量的值就不能改变(必须初始化 如：const b; //报错，必须初始化;)；不存在变量声明提前；   
       
  箭头函数和普通函数的区别？
   答：1、箭头函数是匿名函数，不能作为构造函数，不能使用new;
       2、箭头函数没有原型属性；
       3、箭头函数的this永远指向其上下文的this（指向的是定义它的对象，而不是使用时所在的对象），任何方法都改变不了其指向，如 call(), bind(), apply()；
       4、普通函数的this指向调用它的那个对象。
       
   call()方法返回的结果是打散的参数，apply()返回的是数组，bind（）返回的是函数
       
5、promise:是一个对象，可以获取异步操作的消息，有三种状态：pending(进行中)，resolved(成功), rejected(失败）,一旦状态改变（从pending变为Resolved和从pending变为Rejected),就不会再变。
   promise 对象用then方法，有两个回调函数作为参数，第一个是成功时的回调，第二个是失败时的回调（可选的），两个函数都接受promise对象传出的对象作为参数.
   Promise对象.then(function(){
   // success
   },function(){
   //failure
   });
   
 6、如何实现vue前端跨域，用proxyTable解决
    答：打开config下面的index.js，找到proxyTable，添加以下代码即可：
    '/api': { //替换代理地址名称
      target: 'http://api.douban.com/', //代理地址
     changeOrigin: true, //可否跨域
     pathRewrite: {
     '^/api': '' //重写接口，去掉/api
    }
}
配置完之后需要重启下项目 npm run dev，重启之后，就可以调用，实现跨域了（参考链接地址：https://www.cnblogs.com/zlfProgrammer/p/7997936.html）

7、vue 设置每个页面的title
  答：由于vue文件中只有一个Index.html 文件，title 显示需要通过vue-router来设置
  1：router目录中的index.js里面添加meta属性
  export default new Router({
    // mode: 'history',
  routes: [
      {
      path: '/',
      name: 'Home',
      component: function(resolve){ require(['../components/model/index_home.vue'],resolve)},
      meta: {
        title: '锦穗'
      }
    },{
        //腕表
      path:'/watchPage',
      name:'watchPage',
      component:function(resolve){ require(['../components/model/watchPage/watchPage.vue'],resolve)},
      meta: {
        title: '腕表'
      }
    }]
})
 2：在main.js  在每一个meta里面设置页面的title名字，最后在遍历
 router.beforeEach((to, from, next) => {
  /* 路由发生变化修改页面title */
  if (to.meta.title) {
    document.title = to.meta.title
  }
  next()
})
Vue.beforeEach(function(to,form,next){}) /*在跳转之前执行*/
Vue.afterEach(function(to,form))/*在跳转之后判断*/
在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。
beforeEach函数有三个参数：to:router即将进入的路由对象； from:当前导航即将离开的路由； next:Function,进行管道中的一个钩子，如果执行完了，则导航的状态就是 confirmed （确认的）；否则为false，终止导航。
afterEach函数不用传next()函数； 

 什么是vue生命周期？
  答：vue实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载dom->渲染、更新->渲染、销毁等一系列过程，称为vue的生命周期。
  
vue生命周期的作用是什么？
  它的生命周期中有多个事件钩子，让我们在控制整个vue实例的过程中更容易形成好的逻辑。
  
 vue双向数据绑定的原理？
   就是利用object.defineProperty()这个方法重新定义对象，获取属性值(get)和设置属性值(set)的操作来实现的。
   
 mvvm的理解？
  Model代表数据模型 （也可以在Model中定义数据修改和操作的业务逻辑），
  View 代表ui视图 （它负责将数据模型转化成ui展现出来）
  ViewModel 负责监听数据的改变和控制视图的更新，处理用户交互的。在 Mvvm 架构下，View和Model之间并没有直接联系，而是通过ViewModel进行交互，Model和
  ViewModel之间的交互是双向的，因此View数据的变化会同步到Model中，而Model数据的变化也会立即反应到View上。
这种模式实现了 Model 和 View的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作dom。
  
  
 v-if和v-show区别？
  v-if 按照条件是否渲染；v-show 是display的block或none
  
 怎么定义vue-router的动态路由？怎么获取传过来的值？
   在router目录下的index.js文件中，对pash 属性加上/:id, 使用router对象的params.id获取。
   
 Vue中如何监控某个属性值的变化？
  可以通过 computed 来实现。利用计算属性的特性来实现的，当依赖改变时，便会重新计算一个新值。
  
 简述vue的响应式原理？
   当一个VUE实例创建时，vue会遍历data选项的属性，用object.defineProperty将它们转为 getter/setter 并且在内部追踪相关依赖，在属性被访问和修改时通知
   变化。每个组件实例都有相应的watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而使
   它关联的组件得以更新。

8、Vue-router 中hash模式和history模式的区别？
   答：hash模式url里面永远带着#号，我们在开发当中默认使用这个模式。那么什么时候要用history模式呢？如果用户考虑url的规范那么就需要使用history模式，
  因为history模式没有#号，是个正常的url适合推广宣传。当然其功能也有区别，比如我们在开发app的时候有分享页面，那么这个分享出去的页面就是用vue或是react做的，咱们把这个页面分享到第三方的app里，
  有的app里面url是不允许带有#号的，所以要将#号去除那么就要使用history模式，但是使用history模式还有一个问题就是，在访问二级页面的时候，做刷新操作，会出现404错误，那么就需要和后端人配合让他配置一下apache或是nginx的url重定向，重定向到你的首页路由上就ok啦。

                         hash与history的区别
 	          hash	                 history
url显示:	  有#，很Low	             无#，好看
回车刷新:	可以加载到hash值对应页面	  一般就是404掉了
支持版本:	支持低版本浏览器和IE浏览器	HTML5新推出的API（pushState与replaceState）

总结：
hash模式其实是利用了window可以监听onhashchange事件，也就是说你的url中的哈希值（#后面的值）如果有变化，前端是可以做到监听并做一些响应，这么一来，即使前端并没有发起http请求他也能够找到对应页面的代码块进行按需加载。
history模式里面的2个api作用就是可以将url替换并且不刷新页面,http并没有去请求服务器该路径下的资源，一旦刷新就会显示404。这就需要服务器端做处理，将不存在的路径请求重定向到入口文件（index.html）。
pushState方法不会触发页面刷新，只是导致history对象发生变化，地址栏会有反应。

传统的路由指的是：当用户访问一个url时，对应的服务器会接收这个请求，然后解析url中的路径，从而执行对应的处理逻辑。这样就完成了一次路由分发。
而前端路由是不涉及服务器的，是前端利用hash或者HTML5的history API来实现的，一般用于不同内容的展示和切换。

注意：history模式下，build之后本地 index.html 打开是无效的。 hash模式下，build之后本地 index.html 打开正常！

9、vue中keep-alive的用法？
  答：它是vue的一个内置组件用来缓存组件内容的状态，避免重新渲染（在开发vue项目的时候，有一部分组件是没必要多次渲染的）
  具体用法参考链接： https://blog.csdn.net/fu983531588/article/details/90321827
  
10、 vue跳转不同页面的多种方法？ 
答： <!-- 直接跳转 -->
<router-link to='/testDemo'>
    <button>点击跳转2</button>
</router-link>
 
<!-- 带参数跳转 -->
<router-link :to="{path:'地址',query:{setid:123456}}">
    <button>点击跳转1</button>
</router-link>
 
<router-link :to="{name:'testDemo',params:{setid:1111222}}">
    <button>点击跳转3</button>
</router-link>
----------------------------------------------------------------------------------------------------
2：this.$router.push() 方法
举例：
<template>
    <div id='test'>
        <button @click='goTo()'>点击跳转4</button>
    </div>
</template>
<script>
    export default{
        name:'test',
        methods:{
            goTo(){
                //直接跳转
                this.$router.push('/testDemo');
 
                //带参数跳转
                this.$router.push({path:'/testDemo',query:{setid:123}});   结果为：http://localhost:8080/#/testDemo?setid=123
                this.$router.push({name:'test',params:{setid:111}});   结果为：http://localhost:8080/#/test/111
                this.$router.push({params:{setid:111}});   结果为：http://localhost:8080/#/111 (注意和上一个区别)
            }
        }
    }
</script>

11、vue中scoped深度作用选择器用法？
  如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 >>> 操作符：
  如：<style scoped>
        .a >>> .b { /* ... */ }
      </style>
上述代码将会编译成： .a[data-v-f3f3eg9] .b { /* ... */ }
有些像 Sass/less 之类的预处理器无法正确解析 >>> 这种情况下你可以使用 /deep/ 或 ::v-deep 操作符,两者都是 >>> 的别名，同样可以正常工作;


   
 其他知识点：
 
  1、CSS中link 和@import的区别是？
  答：. link属于HTML标签，而@import是CSS提供的;
      . 页面被加载时，link会同时被加载, 而@import被引用的CSS会等到引用它的CSS文件被加载完再加载;
      . @import是css2.1后提出的(ie5以上才能识别)，而link是不存在兼容问题；
      . js操作DOM，可以使用link改变样式，无法使用@import的方式使用样式
      
   标准盒模型和IE盒模型的区别?
   ps: 每个元素都可以看成是一个容器或一个盒子,这个盒子由4个部分组成：margin,padding,boder,内容；
     答：标准盒模型元素内容的宽=内容的宽 box-sizing:content-box;
         IE盒模型元素内容的宽=元素内容的宽+border+padding  box-sizing:border-box;
         
    em和rem的区别？
    em: 元素的字体大小是根据父元素字体大小设置的;
    rem: 元素的大小是由根元素去决定的；
    
   display:none和visible:hiddlen区别？
    使用 display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;
    而使用visibility:hidden属性后，元素虽然不在页面中显示，但它所占据的空间位置仍然存在；也就是说它仍具有高度、宽度等属性值；
    
  js内置对象有哪些？
    答：js内置对象分为数据封装类对象和其他对象
        数据封装类对象：String，Boolean，Number，Array，和Object;
        其他对象：Function，Arguments，Math，Date，RegExp，Error
        
   js内置函数有哪些？
     大致分五类： 常规函数，数组函数，日期函数，字符串函数，数学函数；
     比如： alert函数、isNAN函数、parseInt、parseFloat函数等
         
  2、判断数组有哪些方法？
  答：1、 instanceof 操作符判断 
      用法：arr instanceof Array； 
      instanceof 主要是用来判断某个实例是否属于某个对象
      例如：let arr = [];
           console.log(arr instanceof Array);  // true
      2、对象构造函数的 constructor判断
      用法：arr.constructor === Array;
      例如：let arr = [];
           console.log(arr.constructor === Array); // true
      3、Array 原型链上的 isPrototypeOf
      用法：Array.prototype.isPrototypeOf(arr)
      例如：let arr = [];
           console.log(Array.prototype.isPrototypeOf(arr)); // true
      4、Object.prototype.toString
      用法：Object.prototype.toString.call(arr) === '[object Array]'
     例如：let arr = [];
          console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true
          
          
   3、 js 数组API:
   
      var a = [1,2], b = [3,4]

     concat();用于两个数组的连接，不会改变原数组，只返回新数组； a.concat(b); //[1,2,3,4]
     join();将数组中的每一项用指定的字符连接起来，不会改变原数组 a.join("-"); //"1-2"

     sort();将数组进行排序，改变原数组，可接受一个比较器函数，如果没有传函数作为参数，则按字符编码进行排序，
     reverse();翻转数组，改变原数组

    slice();截取  从数组中选择一段，作为新数组返回，不会改变原数组；接受两个参数（start, end）如果为负值则倒数，不包括 end 位的值；
    splice();会改变原数组，添加、替换、删除； .splice(index, num, addoption);

    pop();尾部删除
    push();后面添加
    shift();头部删除
    unshift();前面添加 都会改变原数组

    arr.some(function(item,index,arr){
       //条件 return 值
       //依次执行数组中的每个元素，如果有一个元素满足条件就返回 true 否则返回 false
       //遇到满足条件的则不会继续执行下面的循环
       //返回值 true false
       //不会改变原数组
  })

    arr.every(function(item,index,arr){
      //条件 return 值
      //依次执行数组中的每个元素，如果每一个元素满足条件就返回 true 否则返回 false
      //返回值  true false
      //不会改变原数组
 })

    arr.filter(function(item,index,arr){
      //依次执行数组中的每个元素，如果元素满足条件就返回 true 否则返回 false
      //返回值是一个新的数组，如果没有满足条件的返回空数组
      //不会改变原数组
 })

    arr.map(function(item,index,arr){
      //按照原始数组元素顺序依次处理元素,返回相同长度的数组，如果此项没有return,则返回undefined,作为此项的值
     //依次执行数组中的每个元素，对数组中的每个元素进行处理；
     //不会改变原数组，返回一个新数组
     // map()适用于你要改变数据值的时候。不仅仅在于它更快，而且返回一个新的数组。
 })

    arr.forEach(function(item,index,arr){  // 三个参数分别为：当前元素，索引值，加入一个新数组
      // forEach()方法不会返回数据
      // 使用场景：并不打算改变数据的时候，而只是想用数据做一些事情 ，比如存入数据库或则打印出来。
 })

 
                  
      
  3、webpack的理解，和gulp有什么不同？
  答：. webpack是模块打包工具，会分析模块间的依赖关系，然后使用Loaders处理他们，最后生成一个优化并且合并后的静态资源;
      . gulp是前端自动化工具，能够优化前端工作流程，比如文件合并压缩。
      
  4、 什么是作用域？
    答：作用域分为全局作用域和局部作用域（也就是全局变量和局部变量），在es6语法中还增加了块级作用域。
   
  5、什么是事件冒泡？
  从事件源朝父元素一直到根元素（html），当某个元素的某类型事件被触发时，它的父元素的同类型事件也会被触发，一直触发到根元素上。
  
     什么是闭包？
     答：能够读取其他函数内部变量的函数。

  6、javascript公有属性和私有属性区别？
   答：声明一个函数，在函数内通过this声明的属性就是公有属性，用var声明的属性就是私有属性。
   注：私有变量只能在函数内部使用，外部无法访问；公有属性需要对象实例化后才能访问
   
  7、什么是作用域链？
   答：比如我们创建一个函数a,函数a里面又包含一个函数b，那么现在就有三个作用域
   全局作用域(也就是window里面的) ==> 函数a作用域 ==> 函数b作用域
   作用域的特点就是，先在自己的变量范围中查找（有，则停止，不会再往上走），如果找不到，就会沿作用域往上找。

  8、什么是原型链？
   答： 原型链是针对构造函数的，比如我先创建了一个函数，然后通过一个变量new了这个函数，那么这个被new出来的函数就会继承创建出来的那个函数的
   属性，如果我访问被new出来的这个函数的某个属性，但是我并没有在这个new出来的函数中定义这个变量，那么它就会往上（向创建出它的函数中）查找，
   这个查找的过程就叫做原型链。
   Object ==> 构造函数1 ==> 构造函数2
   就和css中的继承一样，如果自身没有定义就会继承父元素的样式。
   例子：function a(){};
         a.prototype.name = "追梦子";
         var b = new a()；
         console.log(b.name); //追梦子
   
  9、什么是函数节流？
   答：函数节流就是针对调用频率比较高的函数，通过设置定时器，让它在执行后间隔一段时间，在进行下一次执行，避免重复频繁的调用导致浏览器性能
   以及ajax重复调用问题。(缺点：重复调用会增加cpu的负担，加载比较慢会导致页面留白)
   最常见的一些需要节流的事件：onresize，scroll，mousemove ,mousehover，因为这些事件会在页面中频繁被触发。
   
   10、对JSON的了解？
    答：全称 JavaScript Object Notation
    两个函数：1. JSON.parse(str)   解析JSON字符串，把JSON字符串变成JavaScript值或对象；
             2、JSON.stringify(obj)   将一个JavaScript值(对象或者数组)转换为一个 JSON字符串；
    eval('('＋json＋')')  用eval方法注意加括号 而且这种方式更容易被攻击
    
    11、JS延迟加载的方式有哪些？
     答：JS的延迟加载有助于提高页面的加载速度。
         defer和async、动态创建DOM方式（用得最多）、按需异步载入JS
         defer：延迟脚本。立即下载，但延迟执行（延迟到整个页面都解析完毕后再运行），按照脚本出现的先后顺序执行。
         async：异步脚本。下载完立即执行，但不保证按照脚本出现的先后顺序执行。
   
   12、加法操作表：
       Number + Number -> 加法运算
       Boolean + Number -> 加法 (如： ture + 0 = 1)
       Boolean + Boolean -> 加法 （如：true + true = 2）
       Number + String -> 连接
       String + Boolean -> 连接
       String + String -> 连接
       
   13、常见http状态码？
   答：200  请求成功
       301  永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。
       400  客户端请求的语法错误
       401  请求要求用户的身份认证
       403  拒绝访问
       404  请求资源不存在
       500  服务器内部错误，无法完成请求
       505  服务器不支持请求的HTTP协议的版本，无法完成处理
       
   14、for…in与for…of的区别？
     例：遍历数组                                                  遍历对象                                                         
         var arr1 = ['a', 'b', 'c'];                             var myObject = {"a": 1, "b": 2, "c": 3};
         arr1.name="数组"                                         for (let key in myObject) {                                                                    console.log(key);                                  }                                     
         for (var i in arr1) {                                        console.log(key)  //a,b,c
           console.log(i)  // 0, 1, 2,name                         }
         };                                                      
	      var arr2 = ['a', 'b', 'c'];                               for (let key of myObject) {
        arr1.name="数组"                                              console.log(key)  // myobject is not iterable
        for (var i of arr2) {                                      }
          console.log(i) // a, b, c,undefined
        };
        
     区别点：
      for in遍历的是数组的索引（即键名）；如果遍历的是对象返回的则是对象的key值；如果遍历的是数组返回的则是数组的下标(key)；
      for of 遍历的是数组元素的值；但是不能遍历对象，因为没有迭代器对象；与forEach()不同的是，它可以正确响应break、continue和return语句；
       
       
   
   
   
   
   
   
   
   
   
   
   
   
   
   
